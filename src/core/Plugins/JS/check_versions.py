import csv
import os

from src.core.Functions.Functions import strip_line
from src.gl.Enums import Color

PGM = 'check_versions'

""" 
Example package-lock.json (auto generated by npm)

    "zen-observable-ts": {
      "version": "0.8.20",
      "resolved": "https://myComp.org/.../zen-observable-ts-0.8.20.tgz",
      "integrity": "sha1-RAkeM10/y8****",
      "requires": {
        "tslib": "^1.9.3",
        "zen-observable": "^0.8.0"
      }
"""


def get_vulnerable_versions(input_path, latest_safe_versions, output_dir=None) -> list:
    err_pfx = f'{PGM}: {Color.RED}Error{Color.NC} - '
    if not input_path or not os.path.isfile(input_path):
        return [f'{err_pfx}Specified input path is not valid or does not exist.']
    if not latest_safe_versions:
        return [f'{err_pfx}No safe versions specified. Nothing to do.']
    if output_dir and not os.path.isdir(output_dir):
        return [f'{err_pfx}Specified output folder is not valid or does not exist.']

    rows = _read_rows(input_path)
    messages = []
    line = 0
    for row in rows:
        line += 1
        for lsv in latest_safe_versions:
            if len(lsv) != 2:
                return [
                    f'{err_pfx}Row in latest_safe_versions should contain 2 elements (key and value), not {len(lsv)}.']
            module = lsv[0]
            safe_version = lsv[1]
            if _get_module_name(row[0]) == module and _is_vulnerable_version(row[1], safe_version):
                messages.append(f'Line {line}: Module {row[0]} version {row[1]} is {Color.RED}vulnerable{Color.NC}. '
                                f'Latest safe {module} version is {safe_version}')
    # Output
    if output_dir:
        file_name = 'versions.csv'
        slash = '\\' if not output_dir.endswith('\\') else ''
        _write_rows(rows, f'{output_dir}{slash}{file_name}')
    return messages


def _read_rows(data_path):
    rows = []
    mode = 'MODULE'
    module_name = ''
    module_version = ''
    with open(data_path, encoding='utf-8-sig') as file:
        for line in file:
            line = strip_line(line)
            label = ''
            value = ''

            p = line.find('requires')
            if p > -1:
                mode = 'REQUIRES'

            # Find Label
            p_colon = line.find(':')
            if p_colon > -1:
                label = _soph(line[:p_colon - 1])
                # a. First time, name of main module.
                if label == 'name':
                    module_name = _soph(line[p_colon:-1])
                # b. Module version
                p_version = line.find('version')
                if p_version > -1:
                    module_version = _soph(line[p_version + 8:])

            # a. Mode
            if line.startswith('}'):
                mode = 'MODULE'
            elif line.endswith('{'):

                if line.find('requires') > -1:
                    mode = 'REQUIRES'
                else:
                    mode = 'MODULE'
                    # Level break. Add previous
                    if module_name:
                        rows.append([module_name, module_version, label, value])
                    # Initialize
                    module_name = label
                    module_version = ''
                    label = ''
                    value = ''

            elif line.endswith(',') and module_name != 'name':
                value = _soph(line[p_colon + 1:-1])
            elif mode == 'REQUIRES':
                value = _soph(line[p_colon + 1:])
            # Add the dependencies right away.
            if mode == 'REQUIRES' and label and value:
                rows.append([module_name, module_version, label, value])
                label = ''
                value = ''

        # Last one: Add previous
        if label and value:
            rows.append([module_name, module_version, label, value])
    return rows


def _soph(value):
    value = value.replace('"', '').replace(':', '').replace(',', '').strip()
    return f"'{value}" if value.startswith('@') else value


def _get_module_name(name) -> str:
    p = name.rfind('/')
    return name[p + 1:] if p > -1 else name


def _is_vulnerable_version(version, safe_version) -> bool:
    """
    As soon as one of the x.x.x elements, from left to right, is > safe version: Safe.
    All x.x.x elements are equal: Safe.
    One of the inputed versions is not valid: still considered Safe.
    """
    input_elems = _get_version_elements(version)
    compare_elems = _get_version_elements(safe_version)
    if input_elems and compare_elems:
        for i in range(0, 2):
            if input_elems[i] < compare_elems[i]:
                return True
            elif input_elems[i] > compare_elems[i]:
                break  # safe version
    return False  # not vulnerable


def _get_version_elements(version: str) -> list or None:
    versions = version.split('.')
    if len(versions) < 3:
        if len(versions) == 1:
            versions.extend(['0', '0'])
        elif len(versions) == 2:
            versions.append('0')
    # Every e.e.e. element should at least contain 1 digit.
    for i in versions:
        if not any(str.isdigit(c) for c in i):
            return None
    return versions


def _write_rows(rows, data_path=None) -> bool:
    """
    Write rows to disk
    """
    if not rows:
        return True

    first = True
    with open(data_path, 'w') as csvFile:
        csv_writer = csv.writer(
            csvFile, delimiter=';', quotechar='"', quoting=csv.QUOTE_MINIMAL, lineterminator='\n')
        for row in rows:
            if first:
                first = False
                header = ['Module', 'Version', 'Requires', 'Version']
                csv_writer.writerow(header)
            csv_writer.writerow(row)
    return True
